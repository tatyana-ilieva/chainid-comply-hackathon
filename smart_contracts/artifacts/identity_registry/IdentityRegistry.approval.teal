#pragma version 10
#pragma typetrack false

// smart_contracts.identity_registry.contract.IdentityRegistry.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0
    bytecblock 0x151f7c75 "admin" "contract_paused" 0x80 "total_verified_users" 0x00
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/identity_registry/contract.py:21-22
    // # Initialize with creator as admin
    // self.admin.value = Address(Global.creator_address)
    bytec_1 // "admin"
    global CreatorAddress
    app_global_put
    // smart_contracts/identity_registry/contract.py:23
    // self.total_verified_users.value = UInt64(0)
    bytec 4 // "total_verified_users"
    intc_1 // 0
    app_global_put
    // smart_contracts/identity_registry/contract.py:24
    // self.contract_paused.value = Bool(False)
    bytec_2 // "contract_paused"
    bytec 5 // 0x00
    app_global_put

main_after_if_else@2:
    // smart_contracts/identity_registry/contract.py:5
    // class IdentityRegistry(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@14
    pushbytess 0x5d47a96c 0xe0c27b0a 0xcfd1392a 0xd7f42674 0x9b1dc48b 0x6af78916 0x346b3dbc 0x01b19a5c 0x02bece11 // method "register_identity(address,uint64)bool", method "verify_identity(address)bool", method "get_total_verified_users()uint64", method "set_admin(address)bool", method "pause_contract()bool", method "unpause_contract()bool", method "get_admin()address", method "is_paused()bool", method "hello(string)string"
    txna ApplicationArgs 0
    match main_register_identity_route@5 main_verify_identity_route@6 main_get_total_verified_users_route@7 main_set_admin_route@8 main_pause_contract_route@9 main_unpause_contract_route@10 main_get_admin_route@11 main_is_paused_route@12 main_hello_route@13

main_after_if_else@16:
    // smart_contracts/identity_registry/contract.py:5
    // class IdentityRegistry(ARC4Contract):
    intc_1 // 0
    return

main_hello_route@13:
    // smart_contracts/identity_registry/contract.py:116
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/identity_registry/contract.py:5
    // class IdentityRegistry(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/identity_registry/contract.py:116
    // @abimethod()
    callsub hello
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_is_paused_route@12:
    // smart_contracts/identity_registry/contract.py:111
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub is_paused
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_admin_route@11:
    // smart_contracts/identity_registry/contract.py:106
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_admin
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_unpause_contract_route@10:
    // smart_contracts/identity_registry/contract.py:99
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub unpause_contract
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_pause_contract_route@9:
    // smart_contracts/identity_registry/contract.py:92
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub pause_contract
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_set_admin_route@8:
    // smart_contracts/identity_registry/contract.py:77
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/identity_registry/contract.py:5
    // class IdentityRegistry(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/identity_registry/contract.py:77
    // @abimethod()
    callsub set_admin
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_total_verified_users_route@7:
    // smart_contracts/identity_registry/contract.py:72
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_total_verified_users
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_verify_identity_route@6:
    // smart_contracts/identity_registry/contract.py:57
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c7580
    log
    intc_0 // 1
    return

main_register_identity_route@5:
    // smart_contracts/identity_registry/contract.py:26
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/identity_registry/contract.py:5
    // class IdentityRegistry(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/identity_registry/contract.py:26
    // @abimethod()
    callsub register_identity
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@14:
    // smart_contracts/identity_registry/contract.py:5
    // class IdentityRegistry(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@16
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts.identity_registry.contract.IdentityRegistry.register_identity(user_address: bytes, verification_level: uint64) -> bytes:
register_identity:
    // smart_contracts/identity_registry/contract.py:26-31
    // @abimethod()
    // def register_identity(
    //     self,
    //     user_address: Address,
    //     verification_level: UInt64
    // ) -> Bool:
    proto 2 1
    // smart_contracts/identity_registry/contract.py:42-43
    // # Contract must not be paused
    // assert not self.contract_paused.value, "Contract paused"
    intc_1 // 0
    bytec_2 // "contract_paused"
    app_global_get_ex
    assert // check self.contract_paused exists
    bytec 5 // 0x00
    ==
    assert // Contract paused
    // smart_contracts/identity_registry/contract.py:45-46
    // # Valid verification level check
    // assert verification_level >= 1 and verification_level <= 3, "Invalid level"
    frame_dig -1
    bz register_identity_bool_false@3
    frame_dig -1
    pushint 3 // 3
    <=
    bz register_identity_bool_false@3
    intc_0 // 1

register_identity_bool_merge@4:
    // smart_contracts/identity_registry/contract.py:45-46
    // # Valid verification level check
    // assert verification_level >= 1 and verification_level <= 3, "Invalid level"
    assert // Invalid level
    // smart_contracts/identity_registry/contract.py:51-52
    // # Increment user count (simplified for MVP)
    // current_count = self.total_verified_users.value
    intc_1 // 0
    bytec 4 // "total_verified_users"
    app_global_get_ex
    assert // check self.total_verified_users exists
    // smart_contracts/identity_registry/contract.py:53
    // self.total_verified_users.value = current_count + 1
    intc_0 // 1
    +
    bytec 4 // "total_verified_users"
    swap
    app_global_put
    // smart_contracts/identity_registry/contract.py:55
    // return Bool(True)
    bytec_3 // 0x80
    retsub

register_identity_bool_false@3:
    intc_1 // 0
    b register_identity_bool_merge@4


// smart_contracts.identity_registry.contract.IdentityRegistry.get_total_verified_users() -> uint64:
get_total_verified_users:
    // smart_contracts/identity_registry/contract.py:75
    // return self.total_verified_users.value
    intc_1 // 0
    bytec 4 // "total_verified_users"
    app_global_get_ex
    assert // check self.total_verified_users exists
    retsub


// smart_contracts.identity_registry.contract.IdentityRegistry.set_admin(new_admin: bytes) -> bytes:
set_admin:
    // smart_contracts/identity_registry/contract.py:77-78
    // @abimethod()
    // def set_admin(self, new_admin: Address) -> Bool:
    proto 1 1
    // smart_contracts/identity_registry/contract.py:88
    // assert Txn.sender == self.admin.value, "Only admin"
    intc_1 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    txn Sender
    ==
    assert // Only admin
    // smart_contracts/identity_registry/contract.py:89
    // self.admin.value = new_admin
    bytec_1 // "admin"
    frame_dig -1
    app_global_put
    // smart_contracts/identity_registry/contract.py:90
    // return Bool(True)
    bytec_3 // 0x80
    retsub


// smart_contracts.identity_registry.contract.IdentityRegistry.pause_contract() -> bytes:
pause_contract:
    // smart_contracts/identity_registry/contract.py:95
    // assert Txn.sender == self.admin.value, "Only admin"
    intc_1 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    txn Sender
    ==
    assert // Only admin
    // smart_contracts/identity_registry/contract.py:96
    // self.contract_paused.value = Bool(True)
    bytec_2 // "contract_paused"
    bytec_3 // 0x80
    app_global_put
    // smart_contracts/identity_registry/contract.py:97
    // return Bool(True)
    bytec_3 // 0x80
    retsub


// smart_contracts.identity_registry.contract.IdentityRegistry.unpause_contract() -> bytes:
unpause_contract:
    // smart_contracts/identity_registry/contract.py:102
    // assert Txn.sender == self.admin.value, "Only admin"
    intc_1 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    txn Sender
    ==
    assert // Only admin
    // smart_contracts/identity_registry/contract.py:103
    // self.contract_paused.value = Bool(False)
    bytec_2 // "contract_paused"
    bytec 5 // 0x00
    app_global_put
    // smart_contracts/identity_registry/contract.py:104
    // return Bool(True)
    bytec_3 // 0x80
    retsub


// smart_contracts.identity_registry.contract.IdentityRegistry.get_admin() -> bytes:
get_admin:
    // smart_contracts/identity_registry/contract.py:109
    // return self.admin.value
    intc_1 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    retsub


// smart_contracts.identity_registry.contract.IdentityRegistry.is_paused() -> bytes:
is_paused:
    // smart_contracts/identity_registry/contract.py:114
    // return self.contract_paused.value
    intc_1 // 0
    bytec_2 // "contract_paused"
    app_global_get_ex
    assert // check self.contract_paused exists
    retsub


// smart_contracts.identity_registry.contract.IdentityRegistry.hello(name: bytes) -> bytes:
hello:
    // smart_contracts/identity_registry/contract.py:116-117
    // @abimethod()
    // def hello(self, name: String) -> String:
    proto 1 1
    // smart_contracts/identity_registry/contract.py:119
    // return String("Hello, ") + name
    pushbytes "Hello, "
    frame_dig -1
    concat
    retsub
