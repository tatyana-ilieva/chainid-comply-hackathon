#pragma version 10
#pragma typetrack false

// smart_contracts.payment_processor.contract.PaymentProcessor.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1
    bytecblock "total_payments_processed" 0x151f7c75 "admin" "contract_paused" 0x80
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/payment_processor/contract.py:13
    // self.admin.value = Address(Global.creator_address)
    bytec_2 // "admin"
    global CreatorAddress
    app_global_put
    // smart_contracts/payment_processor/contract.py:14
    // self.total_payments_processed.value = UInt64(0)
    bytec_0 // "total_payments_processed"
    intc_0 // 0
    app_global_put
    // smart_contracts/payment_processor/contract.py:15
    // self.contract_paused.value = Bool(False)
    bytec_3 // "contract_paused"
    pushbytes 0x00
    app_global_put

main_after_if_else@2:
    // smart_contracts/payment_processor/contract.py:5
    // class PaymentProcessor(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@9
    pushbytess 0x8fa436b3 0x9489d42a 0x346b3dbc 0x9b1dc48b // method "process_payment(address,uint64)bool", method "get_total_payments()uint64", method "get_admin()address", method "pause_contract()bool"
    txna ApplicationArgs 0
    match main_process_payment_route@5 main_get_total_payments_route@6 main_get_admin_route@7 main_pause_contract_route@8

main_after_if_else@11:
    // smart_contracts/payment_processor/contract.py:5
    // class PaymentProcessor(ARC4Contract):
    intc_0 // 0
    return

main_pause_contract_route@8:
    // smart_contracts/payment_processor/contract.py:38
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub pause_contract
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_admin_route@7:
    // smart_contracts/payment_processor/contract.py:33
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_admin
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_total_payments_route@6:
    // smart_contracts/payment_processor/contract.py:28
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_total_payments
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_process_payment_route@5:
    // smart_contracts/payment_processor/contract.py:17
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/payment_processor/contract.py:5
    // class PaymentProcessor(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/payment_processor/contract.py:17
    // @abimethod()
    callsub process_payment
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@9:
    // smart_contracts/payment_processor/contract.py:5
    // class PaymentProcessor(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@11
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.payment_processor.contract.PaymentProcessor.process_payment(recipient: bytes, amount: uint64) -> bytes:
process_payment:
    // smart_contracts/payment_processor/contract.py:17-18
    // @abimethod()
    // def process_payment(self, recipient: Address, amount: UInt64) -> Bool:
    proto 2 1
    // smart_contracts/payment_processor/contract.py:20
    // assert not self.contract_paused.value, "Contract paused"
    intc_0 // 0
    bytec_3 // "contract_paused"
    app_global_get_ex
    assert // check self.contract_paused exists
    pushbytes 0x00
    ==
    assert // Contract paused
    // smart_contracts/payment_processor/contract.py:21
    // assert amount > 0 and amount <= 1000000, "Invalid amount"
    frame_dig -1
    bz process_payment_bool_false@3
    frame_dig -1
    pushint 1000000 // 1000000
    <=
    bz process_payment_bool_false@3
    intc_1 // 1

process_payment_bool_merge@4:
    // smart_contracts/payment_processor/contract.py:21
    // assert amount > 0 and amount <= 1000000, "Invalid amount"
    assert // Invalid amount
    // smart_contracts/payment_processor/contract.py:23
    // current_count = self.total_payments_processed.value
    intc_0 // 0
    bytec_0 // "total_payments_processed"
    app_global_get_ex
    assert // check self.total_payments_processed exists
    // smart_contracts/payment_processor/contract.py:24
    // self.total_payments_processed.value = current_count + 1
    intc_1 // 1
    +
    bytec_0 // "total_payments_processed"
    swap
    app_global_put
    // smart_contracts/payment_processor/contract.py:26
    // return Bool(True)
    bytec 4 // 0x80
    retsub

process_payment_bool_false@3:
    intc_0 // 0
    b process_payment_bool_merge@4


// smart_contracts.payment_processor.contract.PaymentProcessor.get_total_payments() -> uint64:
get_total_payments:
    // smart_contracts/payment_processor/contract.py:31
    // return self.total_payments_processed.value
    intc_0 // 0
    bytec_0 // "total_payments_processed"
    app_global_get_ex
    assert // check self.total_payments_processed exists
    retsub


// smart_contracts.payment_processor.contract.PaymentProcessor.get_admin() -> bytes:
get_admin:
    // smart_contracts/payment_processor/contract.py:36
    // return self.admin.value
    intc_0 // 0
    bytec_2 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    retsub


// smart_contracts.payment_processor.contract.PaymentProcessor.pause_contract() -> bytes:
pause_contract:
    // smart_contracts/payment_processor/contract.py:41
    // assert Txn.sender == self.admin.value, "Only admin"
    intc_0 // 0
    bytec_2 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    txn Sender
    ==
    assert // Only admin
    // smart_contracts/payment_processor/contract.py:42
    // self.contract_paused.value = Bool(True)
    bytec_3 // "contract_paused"
    bytec 4 // 0x80
    app_global_put
    // smart_contracts/payment_processor/contract.py:43
    // return Bool(True)
    bytec 4 // 0x80
    retsub
